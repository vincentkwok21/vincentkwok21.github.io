---
title:  "Starting GLSL language"
mathjax: true
layout: post
categories: media
---
I have been looking into several youtube rabbit holes recently and found a few interesting videos on shader related coding languages, I found a few quick tutorials
on the topic. Looking deeper into shaders and rendering, I've remembered that although I have a graphics card in my desktop computer, I have not really used it yet
for anything besides gaming and some small machine learning training processes. Although I assume it will take a long period of practice before I would put any meaningful load 
onto my GPU, I think it would be cool to say that I have experience in computer generated graphics. I often see computer generated images on the internet and can see many applications for them. Visual synthesizers 
for music and entertainment purposes could be a start. Combining this with some electrical engineering principals on making music and maybe I can make something interesting in the future.



I found a really simple and intuitive [website](https://www.shadertoy.com/new) to get started on GLSL (OpenGL shading language), seems pretty similar syntactically to Java and with a heavy focus on using arithmetic parameter manipulation
to change how images are generated. I found a website that give code templates for you to make a shape such as a circle. I have been challenging myself by incrementally increasing the difficulty
of the graphics I am making, at the time of writing this, I have already learned a few mathematical principles that I honestly should have known before but are great to know now.

Firstly, I created a circle and challenged myself to make a circle with a purple background. Essentially, this requires the code to have a distance function from
a predetermined point to create a circle. It appears that using step functions is a strong way to prevent making gradient colors in GLSL, having a step function makes a clear circle to be formed, where all
values inside can be multiplied to make a circle of a certain color. Since I wanted to manipulate the background instead of the circle, I realized I had to horizontally flip the step function, which ended up in me
learning that all you have to do to flip any function is to make all it's inputs negative, from a programming perspective, this is very easy to implement as well!

{% highlight glsl %}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    // center is considered as (0, 0), and top right corner is (1,1)
    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;
       uv.x *= iResolution.x/iResolution.y; // makes sure the images we create seem like they are on a square canvas even when they are actually on a rectangle
     
    float d = length(uv);
    d -= 0.5;
    //d = abs(d);
    d = step( 0.1, d);
    // Output to screen
    fragColor = vec4(1.0, d, d, 1.0);
}

{% endhighlight %}

![image](https://github.com/vincentkwok21/vincentkwok21.github.io/assets/137122312/8cb15413-9a89-4789-9537-0f53175581f1)![image](https://github.com/vincentkwok21/vincentkwok21.github.io/assets/137122312/1a7023e7-e878-4618-aa34-98e1216ab368)

<sub>^ Left image (Japanese Flag) is created with the code provided, setting both step() parameters negative causes
Right image to show!</sub>


After this I decided to create some sort of temporal motion, following the idea of circles, making concentric circles seems doable, combining the smoothstep() and sin() functions allows me to make concentric circles on a blurry gradient that is not as defined as a normal step function. abs() creates hollow circles. By adding 
a time variable into the sine function and some small scaling, I was able to make a sort of hypnotizing animation, this is getting really interesting!

{% highlight glsl %}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    // center is considered as (0, 0), and top right corner is (1,1)
    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;
       uv.x *= iResolution.x/iResolution.y; // makes sure the images we create seem like they are on a square canvas even when they are actually on a rectangle
     
    float d = length(uv);
    d = sin(d*7.0 + iTime)/7.0; // here You can multipy the d inside sin to create concentric circles, dividing by 7 to create more gradients
    d = abs(d);
    d = smoothstep( 0.0, 0.1, d);
    // Output to screen
    fragColor = vec4(1.0, d, d, 1.0);
}

{% endhighlight %}

{% include embed.html url="https://www.youtube.com/embed/AMw7myJlkm8" %}

<sub>^ red hypnotizing animation!</sub>
